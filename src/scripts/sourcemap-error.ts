/**
 * Prints stack trace from client app production logs using sourcemap files from .output/public/_nuxt directory.
 * To execute:
 * 1. Transform raw stack traces into lines with format [fileName.js]?[lineNumber]:[columnNumber] and paste it into "const errorStack = ..." below
 * 2. Run 'npm run sourcemap-error'
 */

import * as fs from 'fs';
import { join } from 'pathe';
import { destr } from 'destr';
import * as smc from 'source-map';

// Directory containing sourcemaps for all project source files.
// This means all *.map files generated by Nuxt have to be placed in a single directory
const sourceMapsDir = '.output/public/_nuxt';

// Error stack form client browser (logged to server .log file).
// Each line must have the following format: [FileName.js]?[LineNumber]:[ColumnNumber]
const errorStack = ` 
index.3b191592.js?1:82
entry.7ce9efe5.js?1:12455
entry.7ce9efe5.js?1:47485
entry.7ce9efe5.js?1:47642
entry.7ce9efe5.js?1:47661
entry.7ce9efe5.js?1:40419
entry.7ce9efe5.js?1:48932
entry.7ce9efe5.js?1:49015
entry.7ce9efe5.js?1:3954
entry.7ce9efe5.js?1:49293
`;

interface IStackLine extends smc.Position {
  order: number,
  fileName : string,
  originalLine : string
}

async function run () {
  console.log('==== SOURCEMAPPING ERROR STACK ====');
  console.log(`source map directory: ${sourceMapsDir}`);
  console.log(`error stack: ${errorStack}`);

  const parsedStack: IStackLine[] = [];

  const errorLines = errorStack.split('\r').flatMap((v, _) => v.split('\n')).filter((v, _) => v.trim().length > 0);
  console.log(`error lines count: ${errorLines.length}`);
  if (errorLines.length === 0) {
    console.log('stack is empty, exit');
    process.exit(0);
  }

  for (let i = 0; i < errorLines.length; i++) {
    const errorLine = errorLines[i];
    let tokens = errorLine.split('?');
    if (tokens.length !== 2) {
      console.log(`line #${i + 1} has to contain exactly 1 '?' symbol, aborting`);
      process.exit(1);
    }

    const fileName = tokens[0].split('/').pop()!;
    const symbolLocation = tokens[1];
    tokens = symbolLocation.split(':');
    if (tokens.length !== 2) {
      console.log(`line #${i + 1} has to contain exactly 1 ':' symbol in symbol location part, aborting`);
      process.exit(1);
    }

    let lineNumber : number;
    let columnNumber : number;
    try {
      lineNumber = parseInt(tokens[0]);
      columnNumber = parseInt(tokens[1]);
    } catch (err) {
      console.log(`line #${i + 1} has invalid numbers in symbol location part ${symbolLocation}, aborting`);
      process.exit(1);
    }

    parsedStack.push({
      order: i,
      fileName,
      line: lineNumber,
      column: columnNumber,
      originalLine: errorLine
    });
    console.log(`parsed line: file='${fileName}'; lineNumber=${lineNumber}; columnNumber=${columnNumber}`);
  }

  console.log('Result:');
  for (let i = 0; i < parsedStack.length; i++) {
    const trace = parsedStack[i];

    const sourceMapFile = join(sourceMapsDir, trace.fileName + '.map');
    if (!fs.existsSync(sourceMapFile)) {
      console.log(`source map not found for line# ${trace.order}: ${sourceMapFile}, aborting`);
      process.exit(1);
    }

    const mapJson = fs.readFileSync(sourceMapFile, 'utf8');
    console.log(trace.column);
    const map = destr(mapJson) as any;
    const sm = await new smc.SourceMapConsumer(map);
    console.log(sm.originalPositionFor(trace));
    sm.destroy();
  }
}

run();
